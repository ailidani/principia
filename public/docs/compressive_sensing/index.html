<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Introduction # This survey is inspired by a seminar on the topic of crowd sensing systems. In which I have been exposed to the celebrated theory of compressive sensing, also known as compressive sampling or CS, a novel sensing paradigm that can help reduce the sampling rate of sensing tasks. Sampling is data acquisition protocol that aims to recover the original signal of interest. Such signals includes audio, medical images, radio, computer visions, etc."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Compressive Sensing"><meta property="og:description" content="Introduction # This survey is inspired by a seminar on the topic of crowd sensing systems. In which I have been exposed to the celebrated theory of compressive sensing, also known as compressive sampling or CS, a novel sensing paradigm that can help reduce the sampling rate of sensing tasks. Sampling is data acquisition protocol that aims to recover the original signal of interest. Such signals includes audio, medical images, radio, computer visions, etc."><meta property="og:type" content="article"><meta property="og:url" content="/docs/compressive_sensing/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2016-05-27T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-23T23:49:30-07:00"><title>Compressive Sensing | Principia</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.a82d7e77ceb134d151c4d7e381eeb30623fbd5a524d58c584d8716ecec0205bd.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.4cc8a4de41a0fe30692fde53f0af6165c7bfa064d07863f46c119775ebada457.js></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Principia</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><span>Docs</span><ul><li><a href=/docs/abd/>ABD Algorithm</a></li><li><a href=/docs/model-checker/>Model Checker in Go</a></li><li><a href=/docs/topology-mapping/>Topology Mapping Algorithm</a></li><li><a href=/docs/neural-network/>Neural Network</a></li><li><a href=/docs/transaction/>Distributed Transactions</a></li><li><a href=/docs/wankeeper/>WanKeeper: Efficient Distributed Coordination at WAN-scale</a></li><li><a href=/docs/paxos_reconfiguration/>Paxos Reconfiguration</a></li><li><a href=/docs/sonification/>What Paxos sounds like</a></li><li><a href=/docs/compressive_sensing/ class=active>Compressive Sensing</a></li><li><a href=/docs/tla+/>TLA+ wiki</a></li></ul></li><li><span>Blog</span><ul></ul></li></ul><ul><li><a href=https://github.com/ailidani target=_blank rel=noopener>Github</a></li><li><a href="https://scholar.google.com/citations?user=D6PWsuwAAAAJ&hl=en" target=_blank rel=noopener>Google Scholar</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Compressive Sensing</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#introduction>Introduction</a></li><li><a href=#compressive-sensing-primer>Compressive Sensing Primer</a><ul><li><a href=#signals>Signals</a></li><li><a href=#bases>Bases</a></li><li><a href=#sparsity>Sparsity</a></li><li><a href=#sensing-matrices>Sensing Matrices</a></li><li><a href=#incoherent-sampling>Incoherent Sampling</a></li></ul></li><li><a href=#signal-recovery-via-ell_1-minimization>Signal Recovery via $\ell_1$ Minimization</a></li><li><a href=#extensions>Extensions</a><ul><li><a href=#robust-compressive-sampling>Robust Compressive Sampling</a></li><li><a href=#hybrid-cs>Hybrid CS</a></li><li><a href=#multiscale-cs>Multiscale CS</a></li><li><a href=#cost-aware-cs>Cost Aware CS</a></li><li><a href=#distributed-cs>Distributed CS</a></li><li><a href=#generalized-distributed-cs>Generalized Distributed CS</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=introduction>Introduction
<a class=anchor href=#introduction>#</a></h2><p>This survey is inspired by a seminar on the topic of crowd sensing systems. In which I have been exposed to the celebrated theory of compressive sensing, also known as compressive sampling or CS, a novel sensing paradigm that can help reduce the sampling rate of sensing tasks. Sampling is data acquisition protocol that aims to recover the original signal of interest. Such signals includes audio, medical images, radio, computer visions, etc. Traditionally, Shannonâ€™s theorem states that: the sampling rate must be at least twice the maximum frequency present in the signal (Nyquist rate). However, CS suggest that it is possible to surpass the traditional limits, by the fact that we can represent many signals using only a few non-zero coefficients in a suitable basis or dictionary, utilizing nonlinear optimization to enable recovery of such signals from the small set of measurements. Another way to look at it is that rather than measuring at a high rate first, then compressing the sampled data, CS directly sense the data in a compressed form.</p><p>In this survey, we first provide a detailed review of the mathematical foundation underlying compressive sensing problem. Then we present the extensions of CS techniques.</p><h2 id=compressive-sensing-primer>Compressive Sensing Primer
<a class=anchor href=#compressive-sensing-primer>#</a></h2><h3 id=signals>Signals
<a class=anchor href=#signals>#</a></h3><p>Signals can be treated as real-valued functions $f$, with continuous or discrete domains, finite or infinite. Signals produced by natural or man-made systems, usually has discrete, finite domain. We can model such signal as linear structure as vectors living in an $n$-dimensional Euclidean vector space, denoted by $\mathbb{R}^n$. Vector space allow us to add two signals together to generate a new, physically meaningful signal. Other geometry tools such as lengths, distances, angles can also be used to describe and compare signals of interest.</p><p>The length of a vector $x = (x_1, x_2, &mldr;, x_n)$ in $n$-dimensional real vector space $\mathbb{R}^n$ can be given by the Euclidean norm:
$$|x|_2 = (x_1^2 + x_2^2 + &mldr; + x_n^2)^{\frac{1}{2}}$$
The Euclidean distance between two points $x$ and $y$ is the length $|x-y|_2$ of the straight line between the two points. However, the Euclidean distance is insufficient in many situations of a given space. Instead, we make frequent use of the $p$-norms, which are defined for $p \in [0,\infty]$ as</p><p>$$ |x|<em>p = \begin{cases}
| \text{supp}(x) | & \quad p = 0; \
( \sum</em>{i=1}^{n} | x_i |^p )^{\frac{1}{p}} & \quad p \in [1, \infty); \
\text{max} | x_i | & \quad p = \infty \
\end{cases} $$</p><p>where |supp($x$)| = { $i : x_i \neq 0$ } denotes the cardinality of support of $x$.
Also note that, in standard <em>inner product</em> in $\mathbb{R}^n$,
$$ \langle x, x \rangle = x^Tx = \sum_{i=1}^{n}x_i x_i $$
thus $\ell_2$ norm can be writen as $|x|_2 = \sqrt{\langle x,x \rangle}$.
The norms are typically used as a measure of the strength of a signal or size of an error.</p><h3 id=bases>Bases
<a class=anchor href=#bases>#</a></h3><p>Any vector $f \in \mathbb{R}^n$ can be represented by a linear combination of basis vectors ${ \psi_i }<em>{i=1}^{n}$ and (unique) coefficients ${x_i}</em>{i=1}^{n}$, such that
$$f(t) = \sum_{i=1}^{n} x_i \psi_i(t)$$
Let $\Psi$ denote $n \times n$ matrix with $\psi_i$ as columns, $x$ denote vector with entries $x_i = \langle f,\psi_i \rangle$, we can rewrite the equation more compactly as
$$f = \Psi x$$
Discrete Fourier base and discrete cosine base are examples of typical choices for the sparsifying base $\Psi$.</p><h3 id=sparsity>Sparsity
<a class=anchor href=#sparsity>#</a></h3><p>A signal $f$ is $S$-sparse when it has at most $S$ nonzeros, i.e., $|f|<em>0 \leq S$. Signals that are not themselves sparse, but can expressed as $f=\Psi x$ in some basis $\Psi$, where $|x|<em>0 \leq S$, can still be refered as $S$-sparse. When the signal has a sparse expansion, we can discard the small coefficients without much perceptual loss. Formally, $f_S(t)$ is obtained by keeping only the terms corresponding to the $S$ largest values of $x_i$ in above equation, such that $f_S := \Psi x_S$. We have
$$ | f - f_S |</em>{\ell_2} = | x - x_S |</em>{\ell_2} $$
and if the sorted magnitudes of $x_i$ decay quickly, we say $x$ is sparse or compressible, then $x$ is well approximated by $x_S$, therefore, the error $| f-f_S |_{\ell_2}$ is small. In other words, a large fraction of the coefficients can be ignored (set to 0) without much loss.</p><h3 id=sensing-matrices>Sensing Matrices
<a class=anchor href=#sensing-matrices>#</a></h3><p>In this survey, we only consider the standard finite dimensional CS model. Specifically, given a signal $f \in \mathbb{R}^n$, we consider measurement systems that acquire $m$ linear measurements. This process is mathematically represent as
$$ y_k = \langle f, \phi_k \rangle $$
where $k = 1,&mldr;,m$. Let $A$ denote the $m\times n$ sensing matrix with vectors $ \phi_1^* ,&mldr;, \phi_m^* $ as rows (* is the complex transpose), we can rewrite equation as
$$ y = Af $$
The matrix $A$ represents a dimensionality reduction, i.e., it maps $\mathbb{R}^n$ into $\mathbb{R}^m$ where $n\gg m$. We assume that $f$ is a finite-length vector with a discrete-valued index (such as time or space).</p><h3 id=incoherent-sampling>Incoherent Sampling
<a class=anchor href=#incoherent-sampling>#</a></h3><p>With given pair $(\Phi, \Psi)$ of orthobases of $\mathbb{R}^n$, $\Phi$ is sampling matrix as in equation~\ref{eq:measure}, $\Psi$ is basis used to represent $f$ in equation~\ref{eq:basis}.
Definition 1 The coherence between the sensing basis $\Phi$ and representation basis $\Psi$ is
\begin{equation}
\mu(\Phi, \Psi) = \sqrt{n} \cdot \max_{1\leq k,j\leq n} |\langle \phi_k, \psi_j \rangle|.
\end{equation}
The coherence measures the largest correlation between any two elements of $\Phi$ and $\Psi$ \cite{uncertainty}. If there is correlated elements, the coherence is large. Compressive sampling is mainly concerned with low coherence pairs.</p><p>Random matrices are highly incoherent with any fixed basis $\Psi$. If we select $\Phi$ uniformly at random, then with high probability, the coherence between $\Psi$ and $\Phi$ is $\mu(\Phi, \Psi) = \sqrt{2\log n}$.</p><h2 id=signal-recovery-via-ell_1-minimization>Signal Recovery via $\ell_1$ Minimization
<a class=anchor href=#signal-recovery-via-ell_1-minimization>#</a></h2><table><thead><tr><th></th><th style=text-align:center>Key Notations</th></tr></thead><tbody><tr><td>$n$</td><td style=text-align:center>Size of original signal</td></tr><tr><td>$m$</td><td style=text-align:center>Number of measurements</td></tr><tr><td>$S$</td><td style=text-align:center>Size of the support of the signal in sparse domain</td></tr><tr><td>$f$</td><td style=text-align:center>Original signal</td></tr><tr><td>$x$</td><td style=text-align:center>Coefficients</td></tr><tr><td>$e$</td><td style=text-align:center>Error in sample data</td></tr><tr><td>$\Phi$</td><td style=text-align:center>$m \times n$ sampling matrix</td></tr><tr><td>$\Psi$</td><td style=text-align:center>$m \times n$ sparsifying matrix</td></tr><tr><td>$A=\Phi\Psi$</td><td style=text-align:center>Sensing matrix</td></tr></tbody></table><p>To summarize above sections, consider $f\in\mathbb{R}^n$ is a target signal we would like to reconstruct, $f$ can be decomposed under a certain base $\Psi$, i.e. $f = \Psi x$ where $x$ is the coefficient vector. $\Phi$ is a linear encoder which projects an $n$-dimensional data into an $m$-dimensional subspace ($m &lt; n$). CS allows us to reconstruct sparse $f$ from its linear measurements
\begin{equation}
s = \Phi f = \Phi \Psi x
\label{eq:recover}
\end{equation}
In above equation, $m$ can be as small as $O(S\log\frac{n}{S})$ \cite{compressive}. The Sensing matrix $A$ as mentioned in Table 1 has to satisfy the Restricted Isometry Property (RIP) \cite{csstable}.</p><p>Finally, we can perform the $\ell_1$-norm minimization
\begin{equation}
(\mathrm{P}<em>1) \text{arg min}</em>{\hat{x} \in \mathbb{R}^n} |\hat{x} |<em>{\ell_1}, \text{ subject to } \Phi\Psi\hat{x} = y = Ax
\label{eq:l1min}
\end{equation}
where $|x|</em>{\ell_1} := \sum_i |x_i|$.</p><p>This $\ell_1$-norm minimization replaces the NP-hard $\ell_0$-norm minimization that directly searches for the sparsest $\hat{x}$. $\ell_1$-min can be solved in polynomial time by linear programming, besides, various greedy algorithms are also practical alternatives.</p><h2 id=extensions>Extensions
<a class=anchor href=#extensions>#</a></h2><h3 id=robust-compressive-sampling>Robust Compressive Sampling
<a class=anchor href=#robust-compressive-sampling>#</a></h3><p>In section~\ref{sec:math} we have show that how to recover sparse signals from a few measurements. However, to be powerful in practice, CS needs to be able to deal with nearly sparse signals and with noise. In real applications, measured data will inevitably be corrupted by some noise as the sensing device does not have infinite precision. Here, our goal is that small perturbations in the data should cause small perturbations in the reconstruction.
Recovering a vector $x\in\mathbb{R}^n$ from data
$$ y = Ax + e$$
where $A$ is the same $m\times n$ sensing matrix, and $e$ is a stochastic or deterministic unknown error term. We can modify the $\ell_1$ minimization with relaxed constraints for reconstruction:
\begin{equation}
(\mathrm{P}<em>1) \text{arg min}</em>{\hat{x} \in \mathbb{R}^n} |\hat{x} |<em>{\ell_1}, \text{ subject to } |\Phi\Psi\hat{x} - y |</em>{\ell_2} \leq e
\label{eq:l1min2}
\end{equation}</p><h3 id=hybrid-cs>Hybrid CS
<a class=anchor href=#hybrid-cs>#</a></h3><p>In some problems, the compressive sensing model can be deployed in a hybrid way, in particular, CS is not to carry all the load. In such deployment, we can apply CS to measure only fine scale properties of the signal, while ordinary linear measurement and reconstruction was used to obtain the coarse scale properties of the signal.
For example, we can expand the object $x_0$ in the wavelet basis
$$x_0 = \sum_k \beta_{j_0,k}\phi_{j_0,k} + \sum_{j=j_0}^{j_1}\sum_k \alpha_{j,k}\psi_{j,k}$$
where $j_0$ is some specified coarse scale, $j_1$ is the finest scale, $\phi_{j_0,k}$ are mail wavelets at coarse scale and $\psi_{j,k}$ are fine scale female wavelets. $\alpha$ denote the grouping together of all wavelet coefficients, and $\beta$ denote the male coefficients. For male coarse scale coefficients, we take direct measurements, whereas for the female fine scale coefficients, we apply the CS scheme. Let
$$ y = \Phi\Psi^T x_0 $$
To reconstruct from these observations, consider the basis-pursuit optimization problem
\begin{equation}
(\mathrm{BP}) \min_{\hat{x}} |\hat{x}|_{\ell_1} \text{ subject to } y_n = \Phi\Psi^T\Psi \hat{x}
\end{equation}
Results show that Hybrid CS reconstruct signals with even fewer samples and the accuracy is evidently comparable.</p><h3 id=multiscale-cs>Multiscale CS
<a class=anchor href=#multiscale-cs>#</a></h3><p>Inspired by the success of Hybrid CS, we may consider a fully multiscale deployment of CS. We may expand the object $x_0$ in the wavelet basis in the same way, then partition the coefficient vector as $[\beta_{j_0,\cdot}, \alpha_{j_0,\cdot},&mldr;,\alpha_{j_1-1,\cdot}]$. We then apply ordinary linear samping to measure the coefficients $\beta_{j_0,\cdot}$ directly, and then separately apply compressed sensing scale-by-scale, sampling data $y_j$ about the coefficients $\alpha_{j,\cdot}$ at level $j$ using an $n_j \times 2^j$ CS matrix $\Phi_j$. To obtain a reconstruction, we solve the sequence of problems
\begin{equation}
(\mathrm{BP_j}) \min_{\hat{x}} |\hat{x}|_{\ell_1} \text{ subject to } y_j = \Phi_j \hat{x}
\end{equation}</p><h3 id=cost-aware-cs>Cost Aware CS
<a class=anchor href=#cost-aware-cs>#</a></h3><p>In applications like mobile crowd-sensing or wireless sensor networks, the resource burden of collecting samples is usually a major concern. However, the ordinary CS assumes that every sample has the same cost, it simply reduce the number of samples while the Cost Aware CS takes the cost of each sample into consideration. The new objective becomes not only maximizing recovery accuracy, also minimizing the sampling cost. CACS in \cite{cacs} uses Regularized Column Sum (RCS) to predict recovery accuracy, which is equivalent to Statistical RIP (Restricted Isometry Property) condition, to formulate the RCS-constrained Optimization (RO) to fund an optimal randomized sampling strategy $\pi$. In order to make RO solvable, the paper uses two relaxation methods:
\begin{align}
\sigma(F_{\Omega}) \leq \alpha \quad & \to \quad \mathbb{E}[\sigma(F_{\Omega})] \leq \alpha \
\pi \in {0,1}^n \quad & \to \quad \pi \in [0,1]^n
\end{align}</p><p>Then we can use the following convex optimization problem to find an optimal randomized sampling strategy $\pi$ which satisfies the given RCS constraint with the lowest cost.
\begin{align*}
(\mathrm{P}) \min_{\pi} \quad & c^T \pi \
\text{subject to} \quad & 1^T \pi = m \
\quad & (Re(F_j)^T \pi)^2 + (Im(F_j)^T \pi)^2 \leq \alpha^2 \
\quad & 0 \leq \pi_i \leq 1, i = 1,&mldr;,n.
\end{align*}
where $c$ is the cost map, $\pi$ is the sampling strategy, $m$ is the expected sample size, and $Re(F_j)$ and $Im(F_j)$ denote the real and imaginary component of the $j$th column in $F$. Above problem can be solved in polynomial time via standard interior point methods.</p><p>However, RO is centralized algorithm since it requires global information of the cost map, which makes it impractical. The paper further provides two decentralized algorithm that only uses partial information.</p><h3 id=distributed-cs>Distributed CS
<a class=anchor href=#distributed-cs>#</a></h3><p>Distributed Compressive Sensing (DCS) \cite{dcs} improves the signal recovery performance of multi signal ensembles by exploiting both intra- and inter-signal correlation and sparsity structure. DCS is particularly useful in a scenario of multiple sensors carry out the compression in a distributed way without cooperation with each other and transmit the compressed signal to the sink node. At the sink node, the received signals from all the sensors are recovered jointly. The key of DCS is joint sparsity, defined as the sparsity of the entire signal ensemble. DCS consider three types of models as joint sparse signal:</p><p>Each signal is individually sparse, there are also common components shared by every signal, namely common information. This allows joint recovery with a reduced measurements.
All signals share the supports, the locations of the nonzero coefficients.
No signal is sparse itself, nevertheless, they share the large amount of common information.</p><p>One example application for DCS is in \cite{multimodal}, while combining multiple images of the same scene into a single image, they made the constant background image as common information and the variable foreground image as innovation information for efficiency of the process.</p><h3 id=generalized-distributed-cs>Generalized Distributed CS
<a class=anchor href=#generalized-distributed-cs>#</a></h3><p>The Generalized Distributed Compressive Sensing (GDCS) \cite{gdcs} can improve sparse signal detection performance given arbitrary types of common information which are classified into not just full common information as DCS, but also a variety of partial common information.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/ailidani/principia/commit/55abce3ffac1b7cbbdf38aa3ac2adf0c97011846 title='Last modified by eddie | August 23, 2022' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>August 23, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/ailidani/principia/edit/master/content/docs/compressive_sensing.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!0})})</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#introduction>Introduction</a></li><li><a href=#compressive-sensing-primer>Compressive Sensing Primer</a><ul><li><a href=#signals>Signals</a></li><li><a href=#bases>Bases</a></li><li><a href=#sparsity>Sparsity</a></li><li><a href=#sensing-matrices>Sensing Matrices</a></li><li><a href=#incoherent-sampling>Incoherent Sampling</a></li></ul></li><li><a href=#signal-recovery-via-ell_1-minimization>Signal Recovery via $\ell_1$ Minimization</a></li><li><a href=#extensions>Extensions</a><ul><li><a href=#robust-compressive-sampling>Robust Compressive Sampling</a></li><li><a href=#hybrid-cs>Hybrid CS</a></li><li><a href=#multiscale-cs>Multiscale CS</a></li><li><a href=#cost-aware-cs>Cost Aware CS</a></li><li><a href=#distributed-cs>Distributed CS</a></li><li><a href=#generalized-distributed-cs>Generalized Distributed CS</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>