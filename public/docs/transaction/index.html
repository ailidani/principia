<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Occult (Observable causal consistency using lossy timestamps) # Observable causal consistency definition:
Alice write(a=1) -> |Shard A| --x--> |Shard A'| Bob read(a)=1 <- |Shard A| write(b=2) -> |Shard B| -----> |Shard B'| -> read(b) waits for read(a) All existing causally consistent systems are susceptible to slowdown cascades.
Solution: timestamp like vector clocks Write path: Client library attaches its causal timestamp to every write and sends it to the master of the corresponding shard."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Distributed Transactions"><meta property="og:description" content="Occult (Observable causal consistency using lossy timestamps) # Observable causal consistency definition:
Alice write(a=1) -> |Shard A| --x--> |Shard A'| Bob read(a)=1 <- |Shard A| write(b=2) -> |Shard B| -----> |Shard B'| -> read(b) waits for read(a) All existing causally consistent systems are susceptible to slowdown cascades.
Solution: timestamp like vector clocks Write path: Client library attaches its causal timestamp to every write and sends it to the master of the corresponding shard."><meta property="og:type" content="article"><meta property="og:url" content="/docs/transaction/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2017-08-13T00:00:00+00:00"><meta property="article:modified_time" content="2017-08-13T00:00:00+00:00"><title>Distributed Transactions | Principia</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.a82d7e77ceb134d151c4d7e381eeb30623fbd5a524d58c584d8716ecec0205bd.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.3ea095379c68544c8867a35ba6c951296928d8ffa5abecc75c8355e601653b1c.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Principia</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><span>Docs</span><ul><li><a href=/docs/abd/>ABD Algorithm</a></li><li><a href=/docs/model-checker/>Model Checker in Go</a></li><li><a href=/docs/topology-mapping/>Topology Mapping Algorithm</a></li><li><a href=/docs/neural-network/>Neural Network</a></li><li><a href=/docs/transaction/ class=active>Distributed Transactions</a></li><li><a href=/docs/wankeeper/>WanKeeper: Efficient Distributed Coordination at WAN-scale</a></li><li><a href=/docs/paxos_reconfiguration/>Paxos Reconfiguration</a></li><li><a href=/docs/sonification/>What Paxos sounds like</a></li><li><a href=/docs/tla+/>TLA+ wiki</a></li></ul></li></ul><ul><li><a href=https://github.com/ailidani target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Distributed Transactions</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#__occult__-observable-causal-consistency-using-lossy-timestamps><strong>Occult</strong> (Observable causal consistency using lossy timestamps)</a></li><li><a href=#__consus__><strong>Consus</strong></a></li><li><a href=#__slcp__-simple-leaderless-consistency-protocol><strong>SLCP</strong> (Simple Leaderless Consistency Protocol)</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=__occult__-observable-causal-consistency-using-lossy-timestamps><strong>Occult</strong> (Observable causal consistency using lossy timestamps)
<a class=anchor href=#__occult__-observable-causal-consistency-using-lossy-timestamps>#</a></h2><p>Observable causal consistency definition:</p><pre tabindex=0><code>Alice write(a=1) -&gt; |Shard A| --x--&gt; |Shard A&#39;|
Bob   read(a)=1  &lt;- |Shard A|
      write(b=2) -&gt; |Shard B| -----&gt; |Shard B&#39;| -&gt; read(b) waits for read(a)
</code></pre><p>All existing causally consistent systems are susceptible to slowdown cascades.</p><p><em>Solution</em>: timestamp like vector clocks
Write path: Client library attaches its causal timestamp to every write and sends it to the master of the corresponding shard. The master increments the relevant time stamp, updates the received causal timestamp, and stores it with new value. Then asynchronously replicates the writes to its slaves before returning to client library.</p><p>Read path: Read from any slave shard with higher timestamp, or retry read from master. Update local timestamp accordingly.</p><p>Transaction isolations:</p><ul><li><p>Snapshot Isolation</p></li><li><p>Parallel Snapshot Isolation (PSI)</p></li><li><p>Per-Client Snapshot Isolation (PC-PSI) &ndash; Occult</p></li><li><p>Read phase: client $c$ reads from local server for every object $o$ in transaction $T$ and store it as successful reads if it&rsquo;s not stale compare to local shard timestamp. Meanwhile, buffer all writes.</p></li><li><p>Validation phase:</p></li><li><p>Commit phase:</p></li></ul><h2 id=__consus__><strong>Consus</strong>
<a class=anchor href=#__consus__>#</a></h2><p>Consus implements transactions with three phase commit protocol and writes the value into a Generalized Paxos system.</p><p>Assuming data is fully replicated between data centers, the transaction initiator $dc_1$ executes transaction $t$ and broadcast $t$ with its result state $s$ to all other data centers. Other data centers then re-executes $t$ and compare their result state to $s$.</p><p>The commit protocol in consus is too optimistic, would result in high abort rate under heavy write load. There is no evaluation results in the paper.</p><h2 id=__slcp__-simple-leaderless-consistency-protocol><strong>SLCP</strong> (Simple Leaderless Consistency Protocol)
<a class=anchor href=#__slcp__-simple-leaderless-consistency-protocol>#</a></h2><pre tabindex=0><code>Client       Servers
   |         |  |  |
   X--------&gt;|-&gt;|-&gt;|  Write Request (sequence, id)
   |&lt;--------X--X  |  Response
   |         |  |  |
   |         |  |  |
   X--------&gt;|-&gt;|-&gt;|  Read Request (with retry)
   |&lt;--------X--X  |
</code></pre><p>This protocol essentially implement an <em>atomic storage</em> system that provides strong consistency that observable to clients. But it compares the performance with Multi-Paxos and Raft, which are consensus protocols that solves a harder problem.</p><p>The SLCP protocol basically uses a majority write and read quorums. Compare to the majority replication algorithm, SLCP does not require two phases for write operation, and reads are not guaranteed to complement in certain number of rounds.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#__occult__-observable-causal-consistency-using-lossy-timestamps><strong>Occult</strong> (Observable causal consistency using lossy timestamps)</a></li><li><a href=#__consus__><strong>Consus</strong></a></li><li><a href=#__slcp__-simple-leaderless-consistency-protocol><strong>SLCP</strong> (Simple Leaderless Consistency Protocol)</a></li></ul></li></ul></nav></div></aside></main><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></body></html>